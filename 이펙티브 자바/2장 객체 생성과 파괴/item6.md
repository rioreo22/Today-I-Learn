# item6. 불필요한 객체 생성을 피하라

## 1. 객체 재사용
똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나를 재사용하는 편이 나을 때가 많다.<br/>특히 불변 객체!

```java
String s = new String("bikini"); // 실행될 때마다 String 인스턴스 새로 만듦
String s = "bikibi"; // String constant pool 영역에 존재
```

문자열 리터를은 같은 JVM내에서 재사용 보장, String constant pool 영역에서 검색 후, String 객체를 재사용한다. (== 비교 가능해진다.)

[Java String 의 메모리에 대한 고찰](https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc)

+ 원래는 `String constant pool`은 런타임동안 고정된 크기인 `perm`영역에 존재했다. 그런데 `OutOfMemoryException`, `OOM`을 발생 시킬 수 있기 때문에, `heap`영역으로 `String constant pool`의 위치를 변경했다.
+ 따라서 `String constant pool`의 모든 문자열도 GC의 대상이 될 수 있다.
## 2. 정적 팩터리 메서드를 제공하는 불변 클래스
```java
Boolean(String) //deprecated
Boolean.valueOf(String) //권장
```
+ 생성자 대신 정적 팩터리 매서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.
+ 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용 가능


## 3. 생성 비용이 비싼 객체라면 캐싱하여 재사용


## 4. 어댑터 패턴 사용
**어댑터(뷰)** : 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2인터페이스 역할을 해주는 객체. 어댑터는 뒷단 객체만 관리한다. 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분.

Map 인터페이스의 KeySet 메서드 : Map 객체 안의 키를 전부 담은 Set 뷰(어댑터)를 반환

뷰 객체를 여러개 만들거라 생각할 수 있지만, 매번 같은 인스턴스를 반환한다.

## 불필요한 객체를 만들어내는 예시
## 오토박싱
오토박싱 : 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술

기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
```java
private static long sum(){
    Long sum = 0L;
    for(long i =0; i<= Integer.MAX_VALUE; i++)
        sum+=i; // 오토박싱이 일어나서 불필요한 Long 인스턴스 약 2^31개 생성

    return sum;
}
```
**박싱된 기본타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않게 주의하자.**


## 본인만의 객체 풀(pool)을 만들지 말자.
최근의 JVM의 GC는 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.
따라서 "객체 생성은 비싸니 피해야 한다"고 어지간히 무거운 객체가 아닌 이상 객체 풀을 만들지 말자.

- 예시: 데이터베이스 연결 같은 경우 커넥션 풀로 재사용

아이템 50 : 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라. 방어저거 복사 -> 버그와 보안으로 이어짐.
아이템 6 : 불필요한 객체 생성을 피하라 -> 코드 형태 성능에 영향.