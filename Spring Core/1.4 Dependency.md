# 1.4 Dependency

## 1.4.1 Dependency Injection
DI exists in two major variants

1. Constructor-based dependency injection
2. Setter-based dependency injection

## Constructor-based dependency injection
컨테이너에 의해 생성자를 호출한다.
생성자에있는 argument들은 의존성을 나타낸다.
빈을 construct 하기 위해 각 argument들의 static factory method를 호출하는 것과 유사한 방식으로 이루어진다.

### Constructor Argument Resolution
Constructor Argument Resolution matching은 argument's type에 의해 이루어진다. 빈의 정의에 모호한 점이 없으면, 생성자 arguments 순서대로 instaniat 된다.
스프링은 생성자 인자가 기본형 타입일 경우(String, int...) 도움없이 매칭할 수 없다. -> bean 설정에 constructor-arg 에 type, value 값 설정을 해주면 되긴한다.(Constructor argument type matching)


## Setter-based Dependency Injection
Setter-based DI는 컨테이너가 no-arg 생성자나 no-arg static factory 메소드를 호출 한 후, setter methods 들을 호출하여 인스턴스화 하는 방법이다.

# Constructor-based or setter-based DI?
두 개를 짬뽕해서 쓸 수 있음.
하지만 생성자 DI를 쓰고, 추가적인걸 Setter-mothod DI를 쓰기를 권장함.
생성자 위에 @Required 붙여서 필요한 setter를 만들 수 있음.
> **생성자 DI를 인자에 대한 validation과 한께 사용하는 것을 권장함**

스프링 팀은 생성자 DI를 지지함.

1. Lets you implement application components as immutable objects and ensures that required dependencies are not null
2. always returned to the client (calling) code in a fully initialized state
3. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.

Setter DI는 optional로만 써라. DI 할 때마다 non-null 체크 잊지말라.

setter DI하면 장점은, One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is therefore a compelling use case for setter injection.

그리고 third party class를 사용할 때, setter를 지원하지 않으면 생성자 DI만 가능하다.

## Dependency Resolution Process
컨테이너는 빈 dependency resolution을 이렇게 한다.

1. ApplicationContext가 모든 빈들을 설명하는 configutation metadata를 가지고 생성, 초기화 된다.